package PK;

import java.util.Base64;
import java.util.Random;

import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

import com.jian.handle.TokenHandler;
import com.jian.tools.core.CacheTools;
import com.jian.tools.core.JsonTools;
import com.jian.tools.core.Tools;
import com.jian.tools.core.XXTEA;
import com.jian.tools.core.cache.CacheObject;

import Config;
import Constant;
import ServiceException;
import Tips;

/**
 * token工具类
 * 
 * @author liujian
 * @Date 2021/11/02
 *
 */
public class DefaultTokenHandler implements TokenHandler  {

	@Autowired
	private Config config;
	
	//TODO ----------------------------------------------------------------------------------------------------- token
	
	/**
	 * 	获取token字符串。 优先级：cookie > 请求头 > 参数
	 * @return
	 */
	public String getLoginToken() {
		HttpServletRequest req =  ((ServletRequestAttributes)RequestContextHolder.getRequestAttributes()).getRequest();
		return getLoginToken(req);
	}

	/**
	 * 	获取token字符串。 优先级：cookie > 请求头 > 参数
	 * @param req
	 * @return
	 */
	public String getLoginToken(HttpServletRequest req) {
		//读取cookie
		String tokenStr = "";
		Cookie[] cookies = req.getCookies();
		if(cookies != null){
			for (int i = 0; i < cookies.length; i++) {
				Cookie tmp = cookies[i];
				if(config.login_token_name.equals(tmp.getName())){
					tokenStr = tmp.getValue();
					break;
				}
			}
		}
		//Authorization
		if(Tools.isNullOrEmpty(tokenStr)){
			tokenStr = Tools.isNullOrEmpty(req.getHeader("Authorization")) ? "" : Base64.getDecoder().decode(req.getHeader("Authorization").replace("Basic ", "")).toString();
		}
		//header parameter
		if(Tools.isNullOrEmpty(tokenStr)){
			tokenStr = Tools.isNullOrEmpty(req.getHeader(config.login_token_name)) ? Tools.getReqParamSafe(req, config.login_token_name) : req.getHeader(config.login_token_name);
		}
		return tokenStr;
	}
	
	/**
	 * 	检查token是否有效
	 * @param tokenStr	token字符串
	 * @return
	 */
	public boolean checkLoginToken(String tokenStr) {
		if(Tools.isNullOrEmpty(tokenStr)) {
			throw new ServiceException(Tips.ERROR211, config.login_token_name);
		}
		//解码
		tokenStr = tokenStrDecode(tokenStr);
		//提取信息
		String token = getToken(tokenStr);
		String userId = getUserId(tokenStr);
		long time = getTime(tokenStr);
		long expire = getExpire(tokenStr);
		String plat = getPlat(tokenStr);
		//判断超时
		long cur = System.currentTimeMillis();
		if((time + expire) < cur){
			throw new ServiceException(Tips.ERROR214, config.login_token_name);
		}
		//判断格式（md5）
		String str = tokenStr(userId, time, expire, plat);
		return token.equals(tokenMd5(str));
	}

	/**
	 * 	生成新token
	 * @param userId	用户唯一标识
	 * @return	token字符串
	 */
	public String newToken(String userId) {
		return newToken(userId, config.tokenExpireTime, null);
	}

	/**
	 * 	生成新token
	 * @param userId	用户唯一标识
	 * @param platform	平台标识
	 * @return	token字符串
	 */
	public String newToken(String userId, String platform) {
		return newToken(userId, config.tokenExpireTime, platform);
	}

	/**
	 * 	生成新token
	 * @param userId	用户唯一标识
	 * @param expireTime	token有效期（毫秒）
	 * @param platform	平台标识
	 * @return	token字符串
	 */
	public String newToken(String userId, long expireTime, String platform) {
		long curTime = System.currentTimeMillis();
		String plat = getPlatform(platform);
		String str = tokenStr(userId, curTime, expireTime, plat); //原始的字符串
		String token = tokenMd5(str); //md5后的字符串
		String tokenStr = token + config.tokenConnector + str; //md5后的字符串 + 原始的字符串
		tokenStr = tokenStrEncode(tokenStr);//加密后的字符串
		return tokenStr;
	}
	
	/**
	 * 	解密token字符串
	 * @param tokenStr
	 * @return
	 */
	private String tokenStrDecode(String tokenStr){
		String token = tokenStr;
		if(config.tokenEncode) {
			switch (config.tokenEncodeMode) {
			case "xxtea":
				token = new String(XXTEA.decrypt(Base64.getDecoder().decode(tokenStr), config.tokenEncodeKey.getBytes()));
				break;

			default:
				break;
			}
		}
		return token;
	}
	
	/**
	 * 	加密token字符串
	 * @param tokenStr
	 * @return
	 */
	private String tokenStrEncode(String tokenStr){
		String token = tokenStr;
		if(config.tokenEncode) {
			switch (config.tokenEncodeMode) {
			case "xxtea":
				token = Base64.getEncoder().encodeToString(XXTEA.encrypt(tokenStr.getBytes(), config.tokenEncodeKey.getBytes()));
				break;

			default:
				break;
			}
		}
		return token;
	}

	/**
	 *  构成token的原始字符串
	 * @param userId	用户标识
	 * @param curTime	当前时间
	 * @param expireTime	过期时间
	 * @param plat	平台标识
	 * @return
	 */
	private String tokenStr(String userId, long curTime, long expireTime, String plat){
		//userId + time + expire + plat
		String str = userId + config.tokenConnector + curTime + config.tokenConnector + expireTime + config.tokenConnector + plat;
		return str;
	}
	
	/**
	 *  生成token
	 * @param str 原始字符串
	 * @return
	 */
	private String tokenMd5(String str){
		String token = str;
		for (int i = 0; i < config.tokenMd5Count; i++) {
			token = Tools.md5(token + config.tokenSecretKey);
		}
		return token;
	}
	
	/**
	 * 	从token字符串中获取token
	 * @param tokenStr	解密后的token字符串
	 * @return
	 */
	private String getToken(String tokenStr){
		if(tokenStr == null || "".equals(tokenStr) || tokenStr.split(config.tokenSeparator).length < 1) {
			throw new ServiceException(Tips.ERROR200, config.login_token_name);
		}
		return tokenStr.split(config.tokenSeparator)[0];
	}
	
	/**
	 * 	从token字符串中获取用户唯一标识
	 * @param tokenStr	解密后的token字符串
	 * @return
	 */
	private String getUserId(String tokenStr){
		if(tokenStr == null || "".equals(tokenStr) || tokenStr.split(config.tokenSeparator).length < 2) {
			throw new ServiceException(Tips.ERROR200, config.login_token_name);
		}
		return tokenStr.split(config.tokenSeparator)[1];
	}

	/**
	 * 	从token字符串中获取时间
	 * @param tokenStr	解密后的token字符串
	 * @return
	 */
	private long getTime(String tokenStr){
		if(tokenStr == null || "".equals(tokenStr) || tokenStr.split(config.tokenSeparator).length < 3) {
			throw new ServiceException(Tips.ERROR200, config.login_token_name);
		}
		return Long.parseLong(tokenStr.split(config.tokenSeparator)[2]);
	}

	/**
	 * 	从token字符串中获取过期时间
	 * @param tokenStr	解密后的token字符串
	 * @return
	 */
	private long getExpire(String tokenStr){
		if(tokenStr == null || "".equals(tokenStr) || tokenStr.split(config.tokenSeparator).length < 4) {
			throw new ServiceException(Tips.ERROR200, config.login_token_name);
		}
		return Long.parseLong(tokenStr.split(config.tokenSeparator)[3]);
	}

	/**
	 * 	从token字符串中获取登录平台标识
	 * @param tokenStr	解密后的token字符串
	 * @return
	 */
	private String getPlat(String tokenStr){
		if(tokenStr == null || "".equals(tokenStr) || tokenStr.split(config.tokenSeparator).length < 5) {
			throw new ServiceException(Tips.ERROR200, config.login_token_name);
		}
		return tokenStr.split(config.tokenSeparator)[4];
	}
	
	/**
	 * 	获取登录平台标识
	 * @param platform
	 * @return
	 */
	private String getPlatform(String platform) {
		if(!config.allowMultiplePlatformLogin) {
			return config.loginOnDef; //不允许多平台登录，返回默认平台标识
		}
		if(Tools.isNullOrEmpty(platform)) {
			return config.loginOnNull; //平台标识为空，返回默认平台标识
		}
		if(config.loginOnPc.equalsIgnoreCase(platform)) {
			return config.loginOnPc;
		}else if(config.loginOnMobile.equalsIgnoreCase(platform)) {
			return config.loginOnMobile;
		}else if(config.loginOnPad.equalsIgnoreCase(platform)) {
			return config.loginOnPad;
		}else if(config.loginOnOther.equalsIgnoreCase(platform)) {
			return config.loginOnOther;
		}
		if(config.allowUnknownPlatformLogin) {
			return platform; //允许未知平台标识，原样返回
		}
		throw new ServiceException(Tips.ERROR200, "platform");
	}


	//TODO ----------------------------------------------------------------------------------------------------- login
	
	/**
	 * 	缓存登录信息
	 * @param <T>
	 * @param tokenStr	token字符串
	 * @param obj	用户信息
	 */
	public <T> void setLogin(String tokenStr, T obj){
		if(Tools.isNullOrEmpty(tokenStr)) {
			throw new ServiceException(Tips.ERROR211, config.login_token_name);
		}
		//这里会覆盖旧的登录信息，当 allowOnePlatformMultipleLogin = true 时除外。
		String tkey = getTokenCacheKey(Constant.userLoginOn, tokenStr);
		String ukey = getUserCacheKey(Constant.userLoginOn, tokenStr);
		CacheTools.setCacheObj(tkey, tokenStr, config.tokenExpireTime); //缓存登录的信息
		CacheTools.setCacheObj(ukey, JsonTools.toJsonString(obj), config.tokenExpireTime);  //缓存用户的信息
	}

	/**
	 * 	判断是否登录
	 * @return
	 */
	public boolean isLogin() {
		HttpServletRequest req =  ((ServletRequestAttributes)RequestContextHolder.getRequestAttributes()).getRequest();
		return isLogin(req);
	}

	/**
	 * 	判断是否登录
	 * @param req
	 * @return
	 */
	public boolean isLogin(HttpServletRequest req) {
		String tokenStr = getLoginToken(req);
		return isLogin(tokenStr);
	}

	/**
	 * 	判断是否登录
	 * @param tokenStr
	 * @return
	 */
	public boolean isLogin(String tokenStr) {
		if(!checkLoginToken(tokenStr)) {
			throw new ServiceException(Tips.ERROR213, config.login_token_name);
		}
		String tkey = getTokenCacheKey(Constant.userLoginOn, tokenStr);
		CacheObject test = CacheTools.getCacheObj(tkey);
		if(test == null) {
			throw new ServiceException(Tips.ERROR214, "登录");
		}
		return tokenStr.equals(test.getValue()); //与缓存的token字符串比较，判断登录是否还有效
	}

	/**
	 * 	获取登录用户
	 * @param <T>
	 * @param clss	转换类
	 * @return
	 */
	public <T> T getLoginUser(Class<T> clss) {
		HttpServletRequest req =  ((ServletRequestAttributes)RequestContextHolder.getRequestAttributes()).getRequest();
		return getLoginUser(req, clss);
	}
	
	/**
	 * 	获取登录用户
	 * @param <T>
	 * @param req
	 * @param clss	转换类
	 * @return
	 */
	public <T> T getLoginUser(HttpServletRequest req, Class<T> clss) {
		String tokenStr = getLoginToken(req);
		if(!isLogin(tokenStr)) { //判断是否登录
			throw new ServiceException(Tips.ERROR214, config.login_token_name);
		}
		String ukey = getUserCacheKey(Constant.userLoginOn, tokenStr);
		CacheObject test = CacheTools.getCacheObj(ukey);
		if(test == null ) {
			throw new ServiceException(Tips.ERROR214, "登录");
		}
		T user = JsonTools.jsonToObj((String)test.getValue(), clss);
		if(user == null ) {
			throw new ServiceException(Tips.ERROR114, "获取登录用户信息");
		}
		return user;
	}

	/**
	 * 	清除登录信息
	 */
	public void clearLogin() {
		HttpServletRequest req =  ((ServletRequestAttributes)RequestContextHolder.getRequestAttributes()).getRequest();
		clearLogin(req);
	}

	/**
	 * 	清除登录信息
	 * @param req
	 */
	public void clearLogin(HttpServletRequest req) {
		String tokenStr = getLoginToken(req);
		clearLogin(tokenStr);
	}

	/**
	 * 	清除登录信息
	 * @param tokenStr
	 */
	public void clearLogin(String tokenStr) {
		try {
			if(!checkLoginToken(tokenStr)) {
				throw new ServiceException(Tips.ERROR213, config.login_token_name);
			}
		} catch (Exception e) {
			//Do nothing
			System.out.println("清除登录信息：" + e.getMessage());
			return;
		}
		String tkey = getTokenCacheKey(Constant.userLoginOn, tokenStr);
		String ukey = getUserCacheKey(Constant.userLoginOn, tokenStr);
		CacheTools.clearCacheObj(tkey);	//清除Token
		CacheTools.clearCacheObj(ukey); //清除用户信息
	}
	
	/**
	 * 	获取缓存的登录token的key
	 * 	<pre>
	 * 	例如：
	 * 		cacheKeyPrefix = "user:login:on:" 
	 * 		config.allowOnePlatformMultipleLogin = false
	 * 	返回：
	 * 		user:login:on:1:token:123
	 * 	</pre>
	 * @param cacheKeyPrefix 缓存前缀
	 * @param tokenStr	token字符串
	 * @return prefix:plat:token:userId  or  prefix:plat:token:userId:token
	 */
	private String getTokenCacheKey(String cacheKeyPrefix, String tokenStr) {
		tokenStr = tokenStrDecode(tokenStr); //解码
		String userId = getUserId(tokenStr); //token里的用户唯一标识
		String plat = getPlat(tokenStr); //token里的平台
		if(config.allowOnePlatformMultipleLogin) {
			String token = getToken(tokenStr);
			return cacheKeyPrefix + plat + ":token:" + userId + ":" + token; //生成缓存Key(Token)
		}
		return cacheKeyPrefix + plat + ":token:" + userId; //生成缓存Key(Token)
	}
	
	/**
	 * 	获取缓存的登录用户信息的key
	 * 	<pre>
	 * 	例如：
	 * 		cacheKeyPrefix = "user:login:on:" 
	 * 		config.allowOnePlatformMultipleLogin = false
	 * 	返回：
	 * 		user:login:on:1:user:123
	 * 	</pre>
	 * @param cacheKeyPrefix 缓存前缀
	 * @param tokenStr	token字符串
	 * @return prefix:plat:user:userId  or  prefix:plat:user:userId:token
	 */
	private String getUserCacheKey(String cacheKeyPrefix, String tokenStr) {
		tokenStr = tokenStrDecode(tokenStr); //解码
		String userId = getUserId(tokenStr); //token里的用户唯一标识
		String plat = getPlat(tokenStr); //token里的平台
		if(config.allowOnePlatformMultipleLogin) {
			String token = getToken(tokenStr);
			return cacheKeyPrefix + plat + ":user:" + userId + ":" + token; //生成缓存Key(User)
		}
		return cacheKeyPrefix + plat + ":user:" + userId; //生成缓存Key(User)
	}
	
	
	//TODO ----------------------------------------------------------------------------------------------------- password
	

	/**
	 * 	检查用户登录密码
	 * @param userId	用户唯一标识
	 * @param password	加密后的密码（保存在数据库的密码）
	 * @param salt	盐
	 * @param pwd	明文密码（登录时输入的密码）
	 */
	public void checkLoinPassword(String userId, String password, String salt, String pwd) {
		checkLoinPassword(userId, password, pwdMd5(pwd, salt));
	}
	
	/**
	 * 	检查用户登录密码（直接密码密文匹配）
	 * @param userId	用户唯一标识
	 * @param password	加密后的密码（保存在数据库的密码）
	 * @param password2	加密后的密码（登录时输入的密码加密后）
	 */
	public void checkLoinPassword(String userId, String password, String password2) {
		if(Tools.isNullOrEmpty(userId)) {
			throw new ServiceException(Tips.ERROR211, "userId");
		}
		if(Tools.isNullOrEmpty(password)) {
			throw new ServiceException(Tips.ERROR211, "password");
		}
		if(Tools.isNullOrEmpty(password2)) {
			throw new ServiceException(Tips.ERROR211, "password2");
		}
		//时长
		String tkey = Constant.userLoginErrorPwdTime + userId;
		CacheObject tobj = CacheTools.getCacheObj(tkey);
		if(tobj != null) {
			int m = (int)((tobj.getTimeOut() - System.currentTimeMillis()) / (60 * 1000));
			m = m <= 0 ? 1 : m;
			throw new ServiceException(Tips.ERROR108.getCode(), "账号登录失败，请" +m+"分钟后重试。");
		}
		//次数
		String ckey = Constant.userLoginErrorPwdCount + userId;
		if(!password.equals(password2)){
			if(config.maxLoginCount == 0) {
				throw new ServiceException(Tips.ERROR110); //不限次数
			}
			//限制错误次数
			int loinTime = config.maxLoginCount - 1;
			CacheObject cobj = CacheTools.getCacheObj(ckey);
			if(cobj == null){
				CacheTools.setCacheObj(ckey, loinTime);
			}else{
				loinTime = Integer.parseInt(cobj.getValue()+"");
				loinTime--;
				if(loinTime <= 0){
					//进入时长限制
					CacheTools.setCacheObj(tkey, 1, config.maxLoginTime); 
					//解除次数限制
					CacheTools.clearCacheObj(ckey); 
				}else{
					CacheTools.setCacheObj(ckey, loinTime); //更新次数
				}
			}
			throw new ServiceException(Tips.ERROR108.getCode(), "账号登录失败，剩余次数 " + loinTime + " 次");
		}
		//正确
		CacheTools.clearCacheObj(ckey); //解除次数限制
		CacheTools.clearCacheObj(tkey); //解除时长限制
	}

	/**
	 * 	密码md5
	 * @param str	密码
	 * @return
	 */
	public String pwdMd5(String str) {
		return pwdMd5(str, null);
	}
	
	/**
	 * 	密码md5
	 * @param str	密码
	 * @param salt	盐
	 * @return
	 */
	public String pwdMd5(String str, String salt) {
		if(config.pwdAddSalt && salt != null) {
			str = str + salt;
		}
		String pwd = str;
		for (int i = 0; i < config.pwdMd5Count; i++) {
			pwd = Tools.md5(pwd);
		}
		return pwd;
	}
	
	/**
	 * 	生成盐（随机盐 4-9位）
	 * @return
	 */
	public String getSalt() {
    	String val = "";
		Random random = new Random();
		int length = 4 + random.nextInt(6); // 4-9位
		for (int i = 0; i < length; i++) {
//			String charOrNum = i % 2 == 0 ? "num" : "char"; //数字 字母间隔
			String charOrNum = random.nextInt(2) % 2 == 0 ? "num" : "char"; //随机 数字 字母
			
			if ("char".equalsIgnoreCase(charOrNum)){ 
				int choice = random.nextInt(2) % 2 == 0 ? 65 : 97;   //随机 大小 字母
				val += (char) (choice + random.nextInt(26));
			} else if ("num".equalsIgnoreCase(charOrNum)){ 
				val += String.valueOf(random.nextInt(10));
			}
		}
    	return val;
	}

    /**
     * 	密码加密
     * @param data
     * @return
     */
	public byte[] pwdEncode(byte[] data){
		byte[] res = data;
		if(!config.pwdEncode) {
			return res;
		}
		switch (config.pwdEncodeMode) {
		case "xxtea":
			res = XXTEA.encrypt(data, config.pwdEncodeKey.getBytes());
			break;

		default:
			break;
		}
		return res;
	}

    /**
     * 	密码解密
     * @param data
     * @return
     */
	public byte[] pwdDecode(byte[] data){
		byte[] res = data;
		if(!config.pwdEncode) {
			return res;
		}
		switch (config.pwdEncodeMode) {
		case "xxtea":
			res = XXTEA.decrypt(data, config.pwdEncodeKey.getBytes());
			break;
			
		default:
			break;
		}
		return res;
	}
	
}
