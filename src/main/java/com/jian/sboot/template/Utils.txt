package PK;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.UUID;
import java.util.zip.GZIPInputStream;
import java.util.zip.GZIPOutputStream;

import com.jian.annotation.Column;
import com.jian.annotation.FillType;
import com.jian.annotation.PrimaryKey;
import com.jian.annotation.PrimaryKeyCondition;
import com.jian.exception.ToolsException;
import com.jian.tools.core.DateTools;
import com.jian.tools.core.Tools;
import RKey;
import Tips;

public class Utils {

	private static Map<String, List<PrimaryKeyCondition>> pkArrays = new HashMap<String ,List<PrimaryKeyCondition>>();
	private static Map<String, List<String>> colArrays = new HashMap<String ,List<String>>();
	

	
	/**
	 * 参数验证
	 * @param key	参数名
	 * @param value	参数值
	 * @param minLength	最小值
	 * @param maxLength	最大值，为 0 不参与最大长度验证
	 * @return null	通过验证
	 */
	public static Map<String, Object> verifyParam(String key, String value, int minLength, int maxLength) {
		return verifyParam(key, value, minLength, maxLength, false);
	}
	
	/**
	 * 	参数验证
	 * @param key	参数名
	 * @param value	参数值
	 * @param minLength	最小值
	 * @param maxLength	最大值，为 0 不参与最大长度验证
	 * @param isNumber	是否为数字
	 * @return null	通过验证
	 */
	public static Map<String, Object> verifyParam(String key, String value, int minLength, int maxLength, boolean isNumber) {
		Map<String, Object> map = new HashMap<String, Object>();
		
		if(Tools.isNullOrEmpty(value)){
			map.put(RKey.CODE, Tips.ERROR211.getCode());
			map.put(RKey.MSG, Tips.ERROR211.getDesc(key));
			return map;
		}
		//maxLength=0, 不参与长度验证
		if(maxLength > 0){
			if(value.length() > maxLength){
				map.put(RKey.CODE, Tips.ERROR210.getCode());
				map.put(RKey.MSG, Tips.ERROR210.getDesc(key+", 长度"));
				return map;
			}else if(value.length() < minLength && minLength > 0){ //最小值小于等于0不去判断
				map.put(RKey.CODE, Tips.ERROR200.getCode());
				map.put(RKey.MSG, Tips.ERROR200.getDesc(key+", 长度"));
				return map;
			}
		}
		//判断数字
		if(isNumber){
			String tmp = value.replaceAll("[^0-9]", "");
			if(Tools.isNullOrEmpty(tmp) || tmp.length() != value.length()){
				map.put(RKey.CODE, Tips.ERROR200.getCode());
				map.put(RKey.MSG, Tips.ERROR200.getDesc(key));
				return map;
			}
		}
		return null;
	}
	
	
	
	/**
	 * 	获取Entity类注解的PrimaryKey。
	 * @param clss
	 * @return
	 */
	public static List<PrimaryKeyCondition> getPrimaryKeys(Class<?> clss){
		String mark = clss.getCanonicalName();
		List<PrimaryKeyCondition> list = null;
		if(pkArrays.containsKey(mark)){
			list = pkArrays.get(mark);
		}else {
			list = new ArrayList<PrimaryKeyCondition>();
			Field[] fields = Tools.getFields(clss);
			for (Field f : fields) {
				if(f.isAnnotationPresent(PrimaryKey.class)){
					PrimaryKey pk = f.getAnnotation(PrimaryKey.class);
					//数据库字段
					String colName = f.getName();
					if(f.isAnnotationPresent(Column.class)){
						Column col = f.getAnnotation(Column.class);
						//主键忽略exist属性
						colName = Tools.isNullOrEmpty(col.value()) ? colName : col.value();
					}
					colName = Tools.isNullOrEmpty(pk.value()) ? colName : pk.value();
					//对象
					PrimaryKeyCondition node = new PrimaryKeyCondition();
					node.setField(colName); 
					node.setType(f.getType().getSimpleName());
					node.setKeyType(pk.type());
					list.add(node);
				}
			}
			pkArrays.put(mark, list);
		}
		return list;
	}
	
	/**
	 * 	获取Entity类注解为PrimaryKey的数据库字段。
	 * @param clss
	 * @return
	 */
	public static List<String> getPriColumns(Class<?> clss){
		List<PrimaryKeyCondition> list = getPrimaryKeys(clss);
		List<String> keys = new ArrayList<>();
		for (PrimaryKeyCondition pkc : list) {
			String pkn = pkc.getField();
			keys.add(pkn);
		}
		return keys;
	}
	
	/**
	 * 	获取Entity类中需要插入填充的数据库字段。
	 * @param clss
	 * @return
	 */
	public static List<String> getInsertFillColumns(Class<?> clss){
		String mark = clss.getCanonicalName() + "#insertFill";
		List<String> list = null;
		if(colArrays.containsKey(mark)){
			list = colArrays.get(mark);
		}else {
			list = new ArrayList<String>();
			Field[] fields = Tools.getFields(clss);
			for (Field f : fields) {
				if(f.isAnnotationPresent(Column.class)){
					Column col = f.getAnnotation(Column.class);
					if(col.exist() && (col.fill() == FillType.INSERT || col.fill() == FillType.INSERT_UPDATE)) {
						list.add(Tools.isNullOrEmpty(col.value()) ? f.getName() : col.value());
					}
				}
			}
			colArrays.put(mark, list);
		}
		return list;
	}
	
	/**
	 * 	获取Entity类中需要更新填充的数据库字段。
	 * @param clss
	 * @return
	 */
	public static List<String> getUpdateFillColumns(Class<?> clss){
		String mark = clss.getCanonicalName() + "#insertFill";
		List<String> list = null;
		if(colArrays.containsKey(mark)){
			list = colArrays.get(mark);
		}else {
			list = new ArrayList<String>();
			Field[] fields = Tools.getFields(clss);
			for (Field f : fields) {
				if(f.isAnnotationPresent(Column.class)){
					Column col = f.getAnnotation(Column.class);
					if(col.exist() && (col.fill() == FillType.UPDATE || col.fill() == FillType.INSERT_UPDATE)) {
						list.add(Tools.isNullOrEmpty(col.value()) ? f.getName() : col.value());
					}
				}
			}
			colArrays.put(mark, list);
		}
		return list;
	}
	
	/**
	 * 	获取Entity类注解为Column的数据库字段。默认可以不加Column注解
	 * @param clss
	 * @return
	 */
	public static List<String> getColumns(Class<?> clss){
		String mark = clss.getCanonicalName();
		List<String> list = null;
		if(colArrays.containsKey(mark)){
			list = colArrays.get(mark);
		}else {
			list = new ArrayList<String>();
			Field[] fields = Tools.getFields(clss);
			for (Field f : fields) {
				if(f.isAnnotationPresent(Column.class)){
					Column col = f.getAnnotation(Column.class);
					if(col.exist()) {
						list.add(Tools.isNullOrEmpty(col.value()) ? f.getName() : col.value());
					}
				}else{
					list.add(f.getName()); //默认可以不加Column注解
				}
			}
			colArrays.put(mark, list);
		}
		return list;
	}
	
	/**
	 * 	对象属性转数据库字段。
	 * @param clss 对象
	 * @param fieldName 属性名
	 * @return
	 */
	public static String attrToColumn(Class<?> clss, String fieldName){
		try {
			Field field = Tools.findField(clss, fieldName);
			return attrToColumn(field);
		} catch (ReflectiveOperationException e) {
			throw new ToolsException(e);
		}
	}
	
	/**
	 * 	对象属性字段转数据库字段。
	 * @param clss 对象属性字段
	 * @return
	 */
	public static String attrToColumn(Field field){
		String columnName = field.getName();
		if(field.isAnnotationPresent(Column.class)){
			Column col = field.getAnnotation(Column.class);
			if(col.exist()) {
				columnName = Tools.isNullOrEmpty(col.value()) ? field.getName() : col.value();
			}else {
				columnName = ""; //不是数据库字段，置空
			}
		}
		return columnName;
	}
	
	/**
	 * 	对象转数据库字段
	 * @param obj	对象
	 * @return	Map
	 */
	public static Map<String, Object> objectToMap(Object object){
		Map<String, Object> map = new HashMap<String, Object>();
		Field[] fields = Tools.getFields(object.getClass()); //object.getClass().getDeclaredFields();
		Method[] methods = Tools.getMethods(object.getClass()); //object.getClass().getDeclaredMethods();  
		for (Field f : fields) {
			//字段
			String key = f.getName();
			if(f.isAnnotationPresent(Column.class)){
				Column col = f.getAnnotation(Column.class);
				if(!col.exist()) {
					continue; //不存在跳过
				}
				key = col.value();
			}
			//值
			Object value = null;
			// get
			for (Method method : methods) {
				String mname = "get" + f.getName().substring(0,1).toUpperCase() + f.getName().substring(1);
				if(mname.equals(method.getName())){
					try {
						value = method.invoke(object);
					} catch (Exception e) {
						throw new ToolsException(e);
					}
					break;
				}
			}
			//put
			map.put(key, value);
		}
		return map;
	}
	
	/**
	 * 	数据库字段转对象
	 * @param map	字段
	 * @param obj	对象
	 * @return	Map
	 */
	public static <T> T mapToObject(Map<String, Object> map, T obj){
		if(map == null || obj == null) {
			return null;
		}
		Field[] fields = Tools.getFields(obj.getClass()); //object.getClass().getDeclaredFields();
		Method[] methods = Tools.getMethods(obj.getClass()); //object.getClass().getDeclaredMethods(); 
		for (Field f : fields) {
			//字段
			String key = f.getName();
			if(f.isAnnotationPresent(Column.class)){
				Column col = f.getAnnotation(Column.class);
				if(!col.exist()) {
					continue; //不存在跳过
				}
				key = col.value();
			}
			//值
			Object value = map.get(key);
			if(value == null) {
				continue; //不存在值跳过
			}
			// set
			for (Method method : methods) {
				String mname = "set" + f.getName().substring(0,1).toUpperCase() + f.getName().substring(1);
				if(mname.equals(method.getName())){
					try {
						value = transformValue(method.getParameterTypes()[0], value); //类型不匹配，转换类型
						method.invoke(obj, value);
					} catch (Exception e) {
						System.out.println(key);
						System.out.println(method.getName());
						System.out.println(value);
						System.out.println(value.getClass().getName());
						throw new ToolsException(e);
					}
					break;
				}
			}
		}
		return obj;
	}
	
	/**
	 * 	数据库字段转对象
	 * @param map	字段
	 * @param clzz	对象类型
	 * @return	Map
	 */
	public static <T> T mapToObject(Map<String, Object> map, Class<T> clzz){
		if(map == null) {
			return null;
		}
		T obj = null;
		try {
			obj = clzz.newInstance();
		} catch (Exception e) {
			throw new ToolsException(e);
		}
		return mapToObject(map, obj);
	}
	
	/**
	 * 	转换数据类型
	 * @param clazz	目标类型
	 * @param value	
	 * @return
	 */
	public static Object transformValue(Class<?> clazz, Object value) {
		if(clazz == Integer.class) {
			//Byte BigDecimal -> Integer
			if(value instanceof Byte) {
				value = ((Byte) value).intValue();
			}else if(value instanceof BigDecimal) {
				value = ((BigDecimal) value).intValue();
			}
		}else if(clazz == String.class) {
			//Character -> String
			if(value instanceof Character) {
				value = value.toString();
			}
		}
		return value;
	}
	
	@SuppressWarnings("unchecked")
	public static <T> Class<T> getObejctClass(Class<?> clzz){
		Type type = clzz.getGenericSuperclass();
		Class<T> clss = null;
		try {
			Class<?>[] clsses = Tools.getGenericClass((ParameterizedType) type);
			clss = (Class<T>) clsses[0];
		} catch (ClassNotFoundException e) {
			throw new ToolsException(e);
		}
		return clss;
	}

	public static String newUUId() {
		return UUID.randomUUID().toString().replace("-", "");
	}
	
	public static String newUUIdMd5() {
		return Tools.md5(UUID.randomUUID().toString());
	}
	
	public static String newId(String suffix) {
		int random = new Random().nextInt(10000);
		String str = random+"";
		for (int i = 0; i <  4 - str.length(); i++) {
			str = "0" + str;
		}
		return suffix + DateTools.formatDate("yyyyMMddHHmmssSSS") + str;
	}

	public static long newSnowflakeId() {
		return SnowflakeIdWorker.generateId();
	}

	public static String newSnowflakeIdStr() {
		return String.valueOf(SnowflakeIdWorker.generateId());
	}
	
	public static byte[] compress(byte[] buff) throws IOException {
		ByteArrayOutputStream baos = new ByteArrayOutputStream();
		GZIPOutputStream gzos = new GZIPOutputStream(baos);
		gzos.write(buff);
		gzos.close();
		baos.close();
		return baos.toByteArray();
	}
	
	public static byte[] uncompress(byte[] buff) throws IOException {
		ByteArrayOutputStream out = new ByteArrayOutputStream();
		ByteArrayInputStream bais = new ByteArrayInputStream(buff);
		GZIPInputStream gzis = new GZIPInputStream(bais);
		byte[] temp = new byte[1024];
		int len = 0;
		while ((len = gzis.read(temp)) >= 0) {
			out.write(temp, 0, len);
		}
		byte[] receive = out.toByteArray();
		gzis.close();
		bais.close();
		return receive;
	}
	
	public static void main(String[] args) throws IOException {
		byte[] b  = new byte[1000];
		for (int i = 0;i < b.length;++i) {
			b[i] = 65;
		}
		byte[] buff = compress(b);
		System.out.println(buff.length);
		
		byte[] c = uncompress(buff);
		System.out.println(c.length);
	}
}
